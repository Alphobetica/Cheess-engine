use std::ops::Index;
use crate::{BoardRep, PieceColour};
use crate::{ROOK, KNIGHT, BISHOP, QUEEN, KING, PAWN};

// pub type BitBoard = [u64; 8];
#[derive(Debug, Clone, Copy, serde::Serialize, serde::Deserialize)]
pub struct BitBoard(pub [u64; 8]);
impl Default for BitBoard {
    fn default() -> Self {
    BitBoard (
            [
            // Rook
            0b10000001_00000000_00000000_00000000_00000000_00000000_00000000_10000001,
            // Knight
            0b01000010_00000000_00000000_00000000_00000000_00000000_00000000_01000010,
            // Bishop
            0b00100100_00000000_00000000_00000000_00000000_00000000_00000000_00100100,
            // Queen
            0b00001000_00000000_00000000_00000000_00000000_00000000_00000000_00001000,
            // King
            0b00010000_00000000_00000000_00000000_00000000_00000000_00000000_00010000,
            // Pawn
            0b00000000_11111111_00000000_00000000_00000000_00000000_11111111_00000000,
            // White Pieces
            0b00000000_00000000_00000000_00000000_00000000_00000000_11111111_11111111,
            // Black Pieces
            0b11111111_11111111_00000000_00000000_00000000_00000000_00000000_00000000,
            ]
        )
    }
}

impl PartialEq for BitBoard {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl Index<usize> for BitBoard {
    type Output = u64;
    fn index(&self, idx: usize) -> &Self::Output {
        &self.0[idx]
    }
}

pub fn boardrep_to_bitboard (board: &BoardRep) -> BitBoard {
  let mut bitboard: [u64; 8] = [0; 8];
  
//bitwise OR adds the positions of 1 in binary
  for (index, piece) in board.0.iter().enumerate() {
      if piece == &ROOK {
          bitboard[0] = bitboard[0] | POSITION_BITMASK[index]
      } else if piece == &KNIGHT {
          bitboard[1] = bitboard[1] | POSITION_BITMASK[index]
      } else if piece == &BISHOP {
          bitboard[2] = bitboard[2] | POSITION_BITMASK[index]
      } else if piece == &QUEEN {
          bitboard[3] = bitboard[3] | POSITION_BITMASK[index]
      } else if piece == &KING {
          bitboard[4] = bitboard[4] | POSITION_BITMASK[index]
      } else if piece == &PAWN {
          bitboard[5] = bitboard[5] | POSITION_BITMASK[index]
      } else {
          continue;
      }
    }
  for (index, colour) in board.1.iter().enumerate() {
    if colour == &PieceColour::White {
        bitboard[6] = bitboard[6] | POSITION_BITMASK[index]
    } else if colour == &PieceColour::Black {
        bitboard[7] = bitboard[7] | POSITION_BITMASK[index]
    } else {
        continue;
    }
  }
  BitBoard(bitboard)

}
pub fn bitboard_to_boardrep(bitboard: &BitBoard) -> BoardRep {
    let mut piece_board: Vec<u8> = vec![0; 64];
    let mut colour_board: Vec<PieceColour> = vec![PieceColour::Empty; 64];

    for (index, board) in bitboard.0.iter().enumerate() {
        for (square, mask) in POSITION_BITMASK.iter().enumerate() {
            match index {
                0 => {
                    if board & mask == *mask {
                        piece_board[square] = ROOK;
                    }
                },
                1 => {
                    if board & mask == *mask {
                        piece_board[square] = KNIGHT;
                    }
                },
                2 => {
                    if board & mask == *mask {
                        piece_board[square] = BISHOP;
                    }
                },
                3 => {
                    if board & mask == *mask {
                        piece_board[square] = QUEEN;
                    }
                },
                4 => {
                    if board & mask == *mask {
                        piece_board[square] = KING;
                    }
                },
                5 => {
                    if board & mask == *mask {
                        piece_board[square] = PAWN;
                    }
                },
                6 => {
                    if board & mask == *mask {
                        colour_board[square] = PieceColour::White;
                    }
                },
                7 => {
                    if board & mask == *mask {
                        colour_board[square] = PieceColour::Black;
                    }
                },
                
                _ => panic!("Piecetype not allowed in bitboard")
            }
        }
    }
    return (piece_board, colour_board);
}




pub const POSITION_BITMASK: [u64; 64] = [
  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000001,
  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000010,
  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00000100,
  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00001000,
  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00010000,
  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_00100000,
  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_01000000,
  0b00000000_00000000_00000000_00000000_00000000_00000000_00000000_10000000,
  0b00000000_00000000_00000000_00000000_00000000_00000000_00000001_00000000,
  0b00000000_00000000_00000000_00000000_00000000_00000000_00000010_00000000,
  0b00000000_00000000_00000000_00000000_00000000_00000000_00000100_00000000,
  0b00000000_00000000_00000000_00000000_00000000_00000000_00001000_00000000,
  0b00000000_00000000_00000000_00000000_00000000_00000000_00010000_00000000,
  0b00000000_00000000_00000000_00000000_00000000_00000000_00100000_00000000,
  0b00000000_00000000_00000000_00000000_00000000_00000000_01000000_00000000,
  0b00000000_00000000_00000000_00000000_00000000_00000000_10000000_00000000,
  0b00000000_00000000_00000000_00000000_00000000_00000001_00000000_00000000,
  0b00000000_00000000_00000000_00000000_00000000_00000010_00000000_00000000,
  0b00000000_00000000_00000000_00000000_00000000_00000100_00000000_00000000,
  0b00000000_00000000_00000000_00000000_00000000_00001000_00000000_00000000,
  0b00000000_00000000_00000000_00000000_00000000_00010000_00000000_00000000,
  0b00000000_00000000_00000000_00000000_00000000_00100000_00000000_00000000,
  0b00000000_00000000_00000000_00000000_00000000_01000000_00000000_00000000,
  0b00000000_00000000_00000000_00000000_00000000_10000000_00000000_00000000,
  0b00000000_00000000_00000000_00000000_00000001_00000000_00000000_00000000,
  0b00000000_00000000_00000000_00000000_00000010_00000000_00000000_00000000,
  0b00000000_00000000_00000000_00000000_00000100_00000000_00000000_00000000,
  0b00000000_00000000_00000000_00000000_00001000_00000000_00000000_00000000,
  0b00000000_00000000_00000000_00000000_00010000_00000000_00000000_00000000,
  0b00000000_00000000_00000000_00000000_00100000_00000000_00000000_00000000,
  0b00000000_00000000_00000000_00000000_01000000_00000000_00000000_00000000,
  0b00000000_00000000_00000000_00000000_10000000_00000000_00000000_00000000,
  0b00000000_00000000_00000000_00000001_00000000_00000000_00000000_00000000,
  0b00000000_00000000_00000000_00000010_00000000_00000000_00000000_00000000,
  0b00000000_00000000_00000000_00000100_00000000_00000000_00000000_00000000,
  0b00000000_00000000_00000000_00001000_00000000_00000000_00000000_00000000,
  0b00000000_00000000_00000000_00010000_00000000_00000000_00000000_00000000,
  0b00000000_00000000_00000000_00100000_00000000_00000000_00000000_00000000,
  0b00000000_00000000_00000000_01000000_00000000_00000000_00000000_00000000,
  0b00000000_00000000_00000000_10000000_00000000_00000000_00000000_00000000,
  0b00000000_00000000_00000001_00000000_00000000_00000000_00000000_00000000,
  0b00000000_00000000_00000010_00000000_00000000_00000000_00000000_00000000,
  0b00000000_00000000_00000100_00000000_00000000_00000000_00000000_00000000,
  0b00000000_00000000_00001000_00000000_00000000_00000000_00000000_00000000,
  0b00000000_00000000_00010000_00000000_00000000_00000000_00000000_00000000,
  0b00000000_00000000_00100000_00000000_00000000_00000000_00000000_00000000,
  0b00000000_00000000_01000000_00000000_00000000_00000000_00000000_00000000,
  0b00000000_00000000_10000000_00000000_00000000_00000000_00000000_00000000,
  0b00000000_00000001_00000000_00000000_00000000_00000000_00000000_00000000,
  0b00000000_00000010_00000000_00000000_00000000_00000000_00000000_00000000,
  0b00000000_00000100_00000000_00000000_00000000_00000000_00000000_00000000,
  0b00000000_00001000_00000000_00000000_00000000_00000000_00000000_00000000,
  0b00000000_00010000_00000000_00000000_00000000_00000000_00000000_00000000,
  0b00000000_00100000_00000000_00000000_00000000_00000000_00000000_00000000,
  0b00000000_01000000_00000000_00000000_00000000_00000000_00000000_00000000,
  0b00000000_10000000_00000000_00000000_00000000_00000000_00000000_00000000,
  0b00000001_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
  0b00000010_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
  0b00000100_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
  0b00001000_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
  0b00010000_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
  0b00100000_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
  0b01000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
  0b10000000_00000000_00000000_00000000_00000000_00000000_00000000_00000000,
];